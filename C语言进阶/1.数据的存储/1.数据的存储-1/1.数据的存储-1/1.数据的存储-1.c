#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>

//题目：写代码判断当前机器的字节序
//大端字节序：把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低地址处。
//小端字节序：把数据的低位字节序的内容存放在低地址处，高位字节序的内容存放在高地址处。
//int check_sys()
//{
//	int i = 1; //01 00 00 00
//	return (*(char *) & i);  //返回1表示小端  返回0表示大端
//}

//int check_sys()
//{
//	union
//	{
//		int i;
//		char c;
//	}un;
//	un.i = 1;
//	return un.c;
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1) printf("小端\n");
//	else printf("大端\n");
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	//                        11111111  有符号char认为 最高位是符号位
//	//11111111111111111111111111111111  整型提升：按符号位提升
//	signed char b = -1;
//	//                        11111111
//	//11111111111111111111111111111111
//	unsigned char c = -1;
//	//                        11111111  无符号char认为 最高位无符号位
//	//00000000000000000000000011111111  无符号的整型提升：高位一定补0
//	//                                                    高位0正数 原反补相同
//	printf("a = %d b = %d c = %d", a, b, c);
//	//          -1     -1    255
//}

//补充：char 到底是signed char 还是unsigned char？
//C语言标准并没有规定，取决于编译器 - 大多数编译器char 是signed char
//int    signed int
//short  signed short  - 如果不写成unsigned int  unsigned short 指的都是有符号的

//int main()
//{  //1. 一个整数写成补码
//  // 2. 存到内存里只能存8个比特位
////   3. 8个bit要以%u形式打印 - 打印整型 不管是有符号还是无符号都要整型提升 整型提升按原符号位提升 a是char a 有符号char  认为最高位1就是符号位 提升高位补全1
////	 4. 补完后就是提升后的结果，内存存的是补码 以%u形式打印，认为内存存的是无符号数，对于无符号数来说原反补相同 认为提升后的数就是原码直接打印出来
//	char a = -128;
////-128原码  10000000000000000000000010000000
//	//反码  11111111111111111111111101111111
//	//补码  11111111111111111111111110000000  
//
////补码放到char  10000000 
//	//整型提升：char是有符号位 - 按符号位提升
////提升后结果11111111111111111111111110000000
//
////以%u形式打印 认为提升后内存放的是无符号数补码    对于无符号数来说高位不是符号位 相当于是正数―>补码就是原码
//	printf("%u\n", a); // 表示按unsigned int  无符号整型形式打印
//	      //4294967168
//
//	printf("%d\n", a); //写成%d要求出原码
////	提升后结果 是负数 11111111111111111111111110000000 补码
//// 	           1)补码取反+1
////                    10000000000000000000000001111111 反码
////                    10000000000000000000000010000000 原码
////	           2)补码-1取反
//	//                11111111111111111111111101111111 反码
//	//                10000000000000000000000010000000 原码
//	         
//	return 0;
//}

//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000
//    //10000000
//	// 按照原来a的类型来提升
//	//11111111111111111111111110000000
//	printf("%u\n", a);
//	return 0;
//}

//int main()
//{
//	char a = -1;
//		//11111111111111111111111111111111
//		//11111111111111111111111111111110
//		//10000000000000000000000000000001
//	//11111111
//	//    11111111111111111111111111111111
//	printf("%u\n", a);
//	      //4294967295
//	printf("%d\n", a);
////        11111111111111111111111111111111
////        10000000000000000000000000000000
////        10000000000000000000000000000001
//	return 0;
//}

//内存中所有char类型的二进制序列：有符号char的取值范围：-128~127
//00000000 0
//00000001 1
//00000010 2
//01111111 127 正数原反补相同

//10000000 -128  这个数不能算 因为这个二进制序列不能再减1了  这个二进制序列直接被解析当成-128
//10000001 -127   负数补码转原码
// ...
//11111110 -2
//11111111 -1





//11111110
//10000001 -1
//11111101
//10000010 -2
//11111111 -127
//01111111
//00000000
//10000000000000000000000010000000  -128原码
//11111111111111111111111101111111  符号位不变 其他位按位取反
//11111111111111111111111110000000  补码
// 
// 把-128的二进制序列补码存到内存中的char类型中去10000000

//int main() 
//{
//	int i = -20;
//	//10000000000000000000000000010100
//	//11111111111111111111111111101011
//	//11111111111111111111111111101100
//	unsigned int j = 10;
//	//00000000000000000000000000001010
//	printf("%d\n", i + j);
//	//11111111111111111111111111110110
//	//10000000000000000000000000001001
//	//10000000000000000000000000001010
//	//-10
//	return 0;
//}

//int main()
//{//1.当我们去看i时，i看内存里视角时，i的类型说了算
//	unsigned int i; //i是无符号类型 站在i无符号角度 i是无符号数没有负数  没有负数这个数字里最小就是0
//	for (i = 9; i >= 0; i--) 
//	{//而判断条件恰好写的就是i>=0  所以恒成立  什么时候i都不可能<0结束循环
//		printf("%u\n", i); //而i在打印时只是一块内存区域
//		//%u内存里确实是无符号数
//		//%d即使i是无符号整型变量，也认为内存里存的是有符号数字
//	}//2.但i放在printf被打印时，格式又限定了i最终在打印时，被解析成什么样的值
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//-1 -2 ...-128 127 ... 0    -1
//	printf("%d", strlen(a)); //strlen找\0 ASCII码值是0
//	//-1 - 2 ... - 128 127 ... 1        0前面有128+127=255个数字
//	return 0;
//}

