#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//	int a = 20;
//	//20
//	//0000 0000 0000 0000 0000 0000 0001 0100
//	// 00    00    00    14
//	//小端存储：  14 00 00 00
//
//	int b = 10;
//	//10
//	//0000 0000 0000 0000 0000 0000 0000 1010
//	//0a 00 00 00
//
//	int c = -10;
//	//10000000000000000000000000001010
//	//11111111111111111111111111110101
//	//1111111111111111111111111111 0110
//	//f6 ff ff ff
//	return 0;
//}


//01 00 00 00   小端存储第一个字节是01
//00 00 00 01    大端存储第一个字节是00
//通过判断4个字节里第一个字节的数据，就能知道是大端还是小端
//int main()
//{
//	int a = 1;   //整型有4个字节，char*解引用拿到第一个字节
//	//取地址a取出4个字节起始位置的地址，把起始位置的地址放到char*指针变量里
//	char* p = (char*) &a;  //取地址a 本质上取出的是整型的地址int*   非要放到char*的指针变量里 强制类型转换
//	//把a的地址交给p，p就指向a的4个字节的起始地址
//	//对p进行解引用，访问的就是a4个字节里，第一个字节的内容，小端即1
//	//拿出第一个字节的内容，发现是1 说明是小端
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//int check_sys()
//{
//	int i = 1;
//	return *(char*)&i;
//}
//int check_sys()
//{
//	union
//	{
//		int i;
//		char c;
//	}un;
//	un.i = 1;
//	return un.c;
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//整型提升
//int main()
//{//放的数据 存储空间一样大，但理解方式不一样
//	char a = -1;
//	//11111111
//	//有符号char 高位是符号位
//	//%d打印 整形提升看符号位，按符号位提升，符号位是1
//	//补码补1   11111111111111111111111111111111
//	//按位取反  10000000000000000000000000000000
//	//+1        10000000000000000000000000000001
//	//补码以%d形式打印，看的是原码，还是-1
//
//	signed char b = -1;
//	//11111111   同上
//
//	unsigned char c = -1;
//	//无符号的char也是char，是个char就能存8个bit位
//	//11111111
//	//无符号没有符号位概念，全都是有效数字
//	//无符号的整型提升高位一定补0    000000000000000000000000011111111   补码
//	//补码求原码  高位是0说明是正数   正数原反补相同
//
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}

//int main()
//{
//	char a = -128;
//	//负数要写成补码才能存到内存里
//	//原码  10000000000000000000000010000000
//	//反码  11111111111111111111111101111111
//	//补码  11111111111111111111111110000000
//	//截断  10000000
//	//整型提升 char有符号  补1   11111111111111111111111110000000
//	//%u认为 提升后内存 存放的无符号位的补码   %u形式打印，最高位不是符号位   是正数
//	//正数原反补相同
//
//	//%u 以无符号整型形式打印
//	printf("%u\n", a);  //超大数字 4294967168
//	return 0;
//}


//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}

//unsigned char i = 0;
//
//int main()
//{              //无符号char最大能放255   超出截断变为0  i<=255; 恒成立 死循环
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}

// 1E10  等于 1.0*10^10   1.0乘以10的10次方
//int main()
//{
//	//整型和浮点数在内存的存储形式一定是有区别的
//	//整数存储形式：是以补码的二进制序列存进去的，而且涉及大小端顺序的问题
//	int n = 9;
//	float* pFloat = (float*)&n;  //强制类型转换仅仅是让地址类型发生转换，值并没有发生变化
//	printf("n的值为：%d\n", n);  //9
//	printf("*pFloat的值为：%f\n", *pFloat);  //0.000000
//
//	*pFloat = 9.0;  //以浮点数的视角，存储9.0
//	printf("num的值为：%d\n", n);  //1091567616
//	printf("*pFloat的值为：%f\n", *pFloat);  //9.000000   
//	return 0;
//}

// (-1)^s*M*2^E
//(-1)^s表示符号位   s=0时，(-1)的0次方就是1，1乘以后面的数字是正数
//                   s=1时，(-1)的1次方就是-1，-1乘以后面的数字是负数
//M是有效数字，大于等于1，小于2的数字。 二进制的数字不可能大于等于2
//2^E  2的E次方的E表示指数位

//十进制浮点数：5.5   //小数点后的这一位,权重是2^(-1)
//转换成二进制：101.1  --> 转换成科学计数法的表示形式  1.011*2^2  -->  (-1)^0*1.011*2^2
//               小数点向左移动两位，相当于给它乘了2的2次方            s=0   M=1.011  E=2

//5.5  -->  0.55*10^1   -->  0.055*10^2
//10进制的小数点向左移动一位，相当于乘给它乘以10^1   移动两位相当于给它乘以10^2

//32为浮点数，最高的1位是符号位s，紧接着的是8位的指数E，剩下的23位是有效数字

//#include <limits.h>
//#include <float.h>
//
//int main()
//{
//	INT_MAX;
//	FLT_MIN;
//	return 0;
//}