#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//	char str1[] = "hello bit";
//	char str2[] = "hello bit";
//	//str1 str2 数组名代表首元素地址 两个完全不同的数组空间 首元素地址不一样
//	char* str3 = (char*)"hello bit";
//	char* str4 = (char*)"hello bit";
//	//str3 和 str4 指针指向两个常量字符串，常量字符串不能被改，如果内容相等不会存两份，只会存一份
//	//str3里存的是h的地址，str4里存的也是h的地址，str3和str4地址值是一样的 str3 == str4
//	return 0;
//}

//题目 杨式矩阵
//有一个数字矩阵，矩阵的每行从左到右是递增的，矩阵从上到下是递增的，请编写程序在这样的矩阵中查找某个数字是否存在。
//要求：时间复杂度小于O(N) --> 最坏的情况都不能遍历数组
//如果数组里有N个元素，最坏的情况下，把二维数组的N个元素都遍历完,时间复杂度是O(N)
//查找的次数，最坏情况下是N次

//时间复杂度 讨论的是最坏情况下所要操作的次数的次方的层次 N次 还是2N次 还是3N次 都是N的1次方，所有叫O(N)
//如果查找的次数是N的平方 N*N次 N*(N-1) 与N的平方有关 --> 时间复杂度称为O(n^2) n的2次方
//O(1)时间复杂度效率非常高 有N个元素，但不管N是几，只会遍历数组3次或者5次或者7次 常数次这么多次。时间复杂度与N无关，不是2N 也不是N+1 也不是N+5 也不是3N

//1 2 3           1 2 3           3是一行中最大的，也是一列中最小的    3与7比 比7小 3已经是这一行里最大的了 3的左边就没有了 直接可以去掉一行 1 2 3 这一行绝对没有想要的元素 因为3已经是这一行里最大的了
//2 3 4           4 5 6           这一组数字首先调出右上角元素         当 1 2 3 这一行被去掉以后，剩下被查找的元素就是4 5 6 7 8 9了   在被查找的元素中再找出右上角的元素6   6比7小 6是4 5 6这一行中最大的，又是6 9这一列中最小的  7比6大 4 5 6这一行肯定也没有了  查找一次去掉一行，又查找一次又去掉一行  肯定比O要小
//4 5 6           7 8 9           剩下的元素只剩7 8 9了  7 8 9作为数组 右上角的元素就是9  9是7 8 9这一行里最大的，也是只有9这一列元素中最小的    9比7大 说明9这一列中已经没有9了 把9这一列去掉
//                                再被查找元素7和8中 右上角的元素是8  8是7 8这一行中最大的，也是8这一列中最小的 8比7要大  8这一列去掉 这一列已经没有元素了
//                                7与要查找的元素匹配 找到了，如果7比要查找的元素7大，说明7这一列中也没有了 再也找不到了
//                                每查找一次 要么去掉一行 要么去掉一列

//                                找2  3比2大 3是1 2 3这一行中最大的 左边可能有，但是3是3 6 9这一列中最小的 去掉这一列
//                                剩下 1 2    右上角元素与要找的2匹配就找到了
//                                     4 5
//                                     7 8
//这种查找方式不是查找一个，而是查找一行一列 速度更快
//查找左上角不行     1是一行中最小的，也是一列中最小的  如果有一个元素比1大，它可能在右边 也可能在下边  剩下的位置都有可能是要找的元素
//查找右下角也不行   9是一行中最大的，也是一列中最大的  如果有一个元素比9小，它可能在左边 也可能在上边

//查找左下角可以  左下角元素是一行中最小的，是一列中最大的。 如果要找元素比它小 去掉一行；如果要找元素比它大，去掉一列

//int find_num(int arr[3][3], int r, int c, int k)
//{                     传值 形参只是实参的临时拷贝   不会对实参有影响
//	//x，y定位右上角元素   在挪的过程中，行在不断增加，列在不断减小
//	int x = 0;                        //行最大是2
//	int y = c - 1;                   //列最小是0
//
//	//每次找一个右上角元素 找5次  用循环方式来找
//	while (x < r && y >= 0)
//	{
//		if (arr[x][y] < k)
//		{
//			x++;
//		}
//		else if (arr[x][y] > k)
//		{
//			y--;
//		}
//		else
//		{
//			printf("下标是: %d,%d\n", x, y);
//			return 1;
//		}
//	}
//	return 0;
//}

//int main()
//{
//	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
//	int k = 7;
//
//	//在arr 3行3列中寻找k的值  如果找到返回1，如果找不到返回0  用ret接收返回值
//	int ret = find_num(arr, 3, 3, k);  
//	if (ret == 1)
//	{
//		printf("找到了\n");
//	}
//	else
//	{
//		printf("没找到\n");
//	}

	//遍历的方法不满足要求
	//int i = 0;
	//int j = 0;
	//for (i = 0; i < 3; i++)
	//{
	//	for (j = 0; j < 3; j++)
	//	{ 
	//		//某个元素等于7 就找到了
	//		if (arr[i][j] == 7)
	//		{

	//		}
	//	}
	//}
//	return 0;
//}

//int find_num(int arr[3][3], int* px, int* py, int k)
//{
//	//定位坐标
//	int x = 0;
//	int y = *py-1;
//
//	while (x < *px && y >= 0) //临界位置判断
//	{
//		if (arr[x][y] < k)
//		{
//			x++;
//		}
//		else if (arr[x][y] > k)
//		{
//			y--;
//		}
//		else
//		{
//			//当找到元素时，x坐标和y坐标就是找到元素的坐标
//			//算出x y的坐标 最终就是k所在的位置
//			*px = x;  //x赋给*px就是赋给外面的x  把地址传给指针 指针就能改变指向对象的内容
//			*py = y;  //y赋值给*py就是赋值给外面的y
//			return 1;
//		}
//	}
//	return 0;
//}
int find_num(int arr[3][3], int* px, int* py, int k)
{
	int x = *px - 1;
	int y = 0;
	while (x >= 0 && y < *py)
	{
		if (arr[x][y] > k)
		{
			x--;
		}
		else if (arr[x][y] < k)
		{
			y++;
		}
		else
		{
			*px = x;
			*py = y;
			return 1;
		}
	}
	return 0;
}
int main()
{
	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
	int k = 7;
	int x = 3;  //实际的行
	int y = 3;  //实际的列
	//传递地址作用：通过传递指针的方式，可以让函数外部的变量值，跟函数内部指针关联，函数内部就可以操作函数外部的变量值
	//把函数里x和y的值，直接带回到外边的x和y变量   值已经被改了 直接打印

	//                     整型地址 用整型指针变量接收
	//                      x   y 就给带回来了
	int ret = find_num(arr, &x, &y, k);
	//           返回型参数 &x  &y 2个作用:
	//                      1.传入参数 (把值传进去)
	//                      2.带回值   (带回结果)
	if (ret == 1)
	{
		printf("找到了\n");
		printf("下标是：%d %d\n", x, y);
	}
	else
	{
		printf("没找到\n");
	}
	return 0;
}