#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int NumberOf1(int n)
//{
//	int count = 0;
//	int i = 0;
//	for(i = 0; i < 32; i++)
//	{
//		if (((n >> i) & 1) == 1)
//		{
//			count++;
//		}
//	}
//	return count;
//}

//题目：统计二进制中1的个数。写一个函数返回参数二进制中1的个数。输入一个整数，输出该数32位二进制表示中1的个数，其中负数用补码表示。
// 例如：15  00001111  4个1
//最优解 n & (n-1) n与n-1算法会让二进制序列最右边的1去掉 - 只要有1就能通过按位与的方法去掉最右边的1
//                 1）如果n二进制序列最右边原本就是1  减个1就能让最右边的1变成0了 0再与1&相当于这一位去掉了
//                 2) // 1110  n    10 - 1 借一位留下1 变成01，  0与1&去掉1 按位与后面还保持原来的0    
//                       1101
//                 3）n = n & (n-1) n与n-1赋给n 这个表达式就能每一次去掉一个1 
//                 4）n&(n-1)就是去掉n的二进制序列中最后一位的1
// 1111  n    15
// 1110  n-1  14
// 1110  n    14
// 1101  n-1  13
// 1100  n    12
// 1011  n-1  11
// 1000  n    8
// 0111  n-1  7
// 0000  n    0
//int NumberOf1(int n)
//{  //计算参数n的二进制补码中有几个1
//	int count = 0;
//	while (n) //n如果!=0
//	{
//		n = n & (n - 1);
//		count++; //每次执行n = n & (n - 1)这个动作++
//	}
//	return count; //当n==0 while循环停下来 所有1都去掉了，总共去掉几个1？ count里记录返回
//}
//int main()
//{
//	int n = -1;
//	int ret = NumberOf1(n);
//	printf("%d个1\n", ret);
//	return 0;
//}


//题目：写一个代码判断一个数是不是2的n次方
//2^n的数字，其中二进制只有一个1    000010000 只有1个1时，这个1才代表2的几次方
//                                  000001111
//只要这个数是2的n次方，这个数的二进制就只有一个1
//00000001  2的0次方 == 1
//00000010  2的1次方 == 2
//00000100  2的2次方 == 4
//00001000  2的3次方 == 8
//00010000  2的4次方 == 16

//假设要判断的数字是k  k&(k-1) == 0   k和k-1按位与一下，结果如果等于0，就说明k就是2的n次方
//因为如果k是2的n次方，k的二进制里面只有一个1的，k按位与k-1之后，结果就变成0，把二进制中的1去掉了
//如果要判断k是不是2的n次方，只要k&(k-1)的结果等于0 k就是2的n次方；k&(k-1)就是去掉k二进制中最后一位1  如果二进制只有一个1，一次就去掉
//int OnlyOne1(int k)
//{
//	if ((k & (k - 1)) == 0)
//		return 1;
//	else
//		return 0;
//}
//int main()
//{
//	int k = 8;
//	int ret = OnlyOne1(k);
//	if (ret == 1)
//	{
//		printf("%d是2的n次方\n", k);
//	}
//	else
//	{
//		printf("%d不是2的n次方\n", k);
//	}
//
//	return 0;
//}


//题目：求两个数二进制中不同位的个数。 两个int（32位）整数m和n的二进制表达中，有多少个位（bit）不同？
//      输入两个整数，求两个整数二进制格式有多少个位不同。
// 方法1：循环32次
//int main()
//{
//	int m = 0;
//	int n = 0;
//	int i = 0;
//	int count = 0;
//	scanf("%d%d", &m, &n);
//	for (i = 0; i < 32; i++)
//	{
//		if (((m >> i) & 1) != ((n >> i) & 1))
//		{
//			count++;
//		}
//	}
//	printf("%d\n", count);
//	return 0;
//}

// 最优解 方法2：有多少个1就循环多少次
//int NumberOf1(int n)
//{  //计算参数n的二进制补码中有几个1
//	int count = 0;
//	while (n) //n如果!=0
//	{
//		n = n & (n - 1); //01100
//                         //01011
//		                 //01000
//		count++; //每次执行n = n & (n - 1)这个动作++
//	}
//	return count; //当n==0 while循环停下来 所有1都去掉了，总共去掉几个1？ 就有几个1  count里记录返回
//}
//
//int main()
//{
//	int m = 0; //1999    22
//	int n = 0; //2299    33
//	           //7       5
//	scanf("%d%d", &m, &n);
//
//	int ret = m ^ n; //ret按位异或结果 相异为0 相同为1
//	int count = NumberOf1(ret);
//
//	printf("%d\n", count); //打印有多少个不相同的位
//
//	return 0;
//}

//题目：打印整数二进制位的奇数位和偶数位。 获取一个二进制序列中所有的偶数位和奇数位，分别打印出二进制序列
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	//获取n的二进制中的奇数位和偶数位
//	//00000000000000000000000000001010
//	//最高位移到最低位移动31位，移32位就丢了
//	int i = 0;
//
//	//打印偶数位  32位->2位  32-2=第30位偶数位  -2移动下一个偶数位
//	for (i = 31; i >= 1; i -= 2)
//	{
//		printf("%d ", (n >> i) & 1); //按位与：原本是1打印1 原本是0打印0
//	}
//	printf("\n");
//
//	//打印奇数位 31位->1位  31-2=第29位奇数位   -2移动下一个奇数位
//	for (i = 30; i >= 0; i -= 2)
//	{
//		printf("%d ", (n >> i) & 1);
//	}
//	printf("\n");
//
//	return 0;
//}

//题目：不使用变量交换两整数
//int main()
//{
//	int a = 10;
//	int b = 20;
//	printf("a = %d b = %d\n", a, b);
//	a = a ^ b; //拿到密码 a里放的是a和b异或的结果
//	b = a ^ b; // 把a替换成a ^ b  就是a ^ b ^ b  两个b异或是0  0与a异或是a。 此时表达式a ^ b的结果是原来的a，原来的a放到b里
//	a = a ^ b; // 此时a里放的是a ^ b的结果   b里放的是原来的a    a ^ b ^ a
//	printf("a = %d b = %d\n", a, b);
//	return 0;
//}

//1的二进制表现形式：   00000000 00000000 00000000 00000001
//1的十六进制表现形式：    00       00       00       01   //4个二进制位可以换1个十六进制位
int arr[] = { 1,2,3,4,5 };
short* p = (short*)arr; //强制类型转换 让arr能放到short里去