#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//bug臭虫 找bug的过程叫作调试
//Debugging/Debug调试又称除错，是发现和减少计算机程序和电子仪器设备中 程序错误的一个过程。
//Debug 调试版本  Release 发布版本
//void test()
//{
//	int a = 10;
//	int b = 20;
//	int c = a + b;
//}
//int main()
//{
//	int arr[10] = { 0 };
//	int sz = sizeof(arr) / sizeof(arr[0]); //求数组元素个数
//
//	int i = 0;
//	for (i = 0; i < sz; i++) //遍历数组
//	{
//		arr[i] = i + 1; //给数组每一个元素 赋一个值
//	}
//
//	for (i = 0; i < sz; i++)
//	{
//		/*test();*/
//		printf("%d\n", arr[i]);
//	}
//
//	//char* p = "hello bit";
//	//printf("%s\n", p); //现在指针变量p里 存放的是字符串，不是地址 直接%s打印字符串即可
//
//	return 0;
//}

//F5 启动调试 - 直接跳到断点处
//F9 设置/取消断点  - 右击鼠标条件 条件断点：通过条件满足时才命中断点
//F10 逐过程
//F11 逐语句 - 进入函数 - 细度更高
//Ctrl+F5 开始执行(不调试) - 设了断点也不调试 - 即使有断点也不会停下来
//Fn 辅助功能键 

//void test2()
//{
//	printf("hehe\n");
//}
//void test1()
//{
//	test2();
//}
//void test()
//{
//	test1();
//}
//int main()
//{//main函数是程序执行入口   调用堆栈：反馈函数的调用逻辑
//	test();
//	return 0;
//}

//迭代 求 1! + 2! + 3! + ... + n！和
//        1! + 2! + 3! + 4! + 5！= 153
//int main()
//{
//	int n = 0;
//	scanf("%d", & n);
//	int ret = 1; //ret从1开始 因为0乘任何数字都是0
//	int sum = 0;
//
//	int i = 1;
//	for (i = 1; i <= n; i++) //for循环产生1到n的数字
//	{
//		ret *= i;
//		sum += ret; //每一次算出一个阶乘之后+在一起
//	}
//	printf("%d\n",sum);
//
//	return 0;
//}

//int main()
//{
//	int n = 0;
//	int i = 0;
//	int j = 0;
//	int sum = 0; //保存最终结果
//	int ret = 1; //保存n的阶乘
//	scanf("%d", &n);
//
//	for (j = 1; j <= n; j++)
//	{
//		ret = 1; //每次循环要把ret初始化成1
//		for (i = 1; i <= j; i++)
//		{
//			ret *= i; //ret在求每一次j（3）的阶乘时，都使用上一次留下来的值不合理
//		}
//		sum += ret;
//	}
//	printf("%d\n", sum);
//}

//递归 求n！
//int Fac(int n)
//{
//	/*if (n > 1)
//		return n * Fac(n - 1);
//	else
//		return 1;*/
//
//	if (1 >= n)
//		return 1;
//	else
//		return n * Fac(n - 1);
//}
//
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//
//	int ret = Fac(n);
//	printf("%d! = %d\n",n, ret);
//
//	return 0;
//}

int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("&i = %p\n", &i); //因为release不能调试监视 所以打印
	printf("arr = %p\n", arr); //因为release不能调试监视 所以打印
	//变量在内存中开辟的顺序发生了变化，影响了程序的执行结果
	for (i = 0; i <= 12; i++) 
		            //代码运行结果：死循环
	{              //为什么越界程序会死循环？
		           //1.因为i和arr是两个局部变量，先创建i，再创建arr；
		           //2.又因为局部变量是放在栈区上的，栈区的使用习惯是：先使用高地址，再使用低地址，所以栈区内存的布局就是这样子的。
		           //3.又因为数组随着下标的增长，地址是由低到高变化的，所以如果数组用下标访问时，只要适当的往后越界，就有可能覆盖到i
		          //   而如果i被覆盖的话，就可能导致程序死循环。
		arr[i] = 0; //索引“12”超出了“0”至“9”的有效范围(对于可能在堆栈中分配的缓冲区“arr”)
		printf("hehe\n");
	}
	return 0;
}

//i的地址和arr[12]的地址一样说明：i和arr[12]是同样的空间 - 数组越界 稍微往后访问的时候，就访问到i了
															 //数组越界 越界位置合适就能访问到i
															 //如果越到12恰好就是i，把12改掉就把i改掉了，把i改掉就有可能导致死循环，因为i永远都不可能大于12了
																				  //i只要++成12 把12的元素一改成0，i就改成0，这个地方就死循环了
//巧合：恰好i的地址就在索引12地址的位置，因为i<=12 过来之后，i和arr[12]重叠，把arr[12]改就把i改

//越界 非法访问 程序出问题

//VC6.0环境 - 中间空 0个整型 - i和arr数组是紧挨着放的 只要越界一个 i<=10 就死循环了
//  gcc环境 -        1个整型 - i和arr数组隔1个整型        越界两个 i<=11   死循环
//   VS环境 -        2个整型 - i和arr数组隔2个整型        越界三个 i<=12   死循环

//栈的存储结构和写代码的顺序 完全有机会、有可能导致死循环

//在gcc环境下，内存栈区上变量i和a中间空1个整型，越界1个整型，16变成17的时候，程序运行结果就会死循环。
