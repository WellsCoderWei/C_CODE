#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <assert.h>

//void my_strcpy(char* dest, const char* src) //传空指针src没有指向 没有指向合法空间 *src解引用就出问题了
//{     
//    //不期望某个事情发生，当某个事情真的发生时asser就会把错误信息告诉我们，明确知道这个错误文件的在哪一行
////src是指针 src == NULL 断言就会报错     空指针是不能解引用操作 访问内存的
//	assert(src != NULL); //断言：不允许发生什么事情时 条件为假 断言就会报错；满足某个条件时 条件为真 断言什么事也不会发生。  断言里放判断条件，不一定断言指针，条件为真什么事也不发生，条件为假报错 什么都可以判断 例如：某个变量等于5 a==5
//	assert(dest != NULL); //只要是你想判断的东西都可以，最终看的是表达式的结果是真还是假。只要能产生一个结果，是一个表达式都可以作为断言条件
//	while (*src++ = *dest++) //*src++ = *dest++ 写反之后把*dest考到*src  xxxxxx拷贝到hello里了 arr1字符串比arr2长放不下 程序崩溃
//		                     //如何很容易知道拷反呢？
//	{                //拷贝完之后才++ 就是后置++   *解引用是本来的值 用完之后再++
//		//赋值表达式 赋值之后结果是几，就是谁
//		;
//	}
//	//h就是*src  如果再让*src赋给*dest就是循环了 \0是最后拷贝的字符，也是循环停下来的标志
//}
//int main()
//{
//	char arr1[20] = "xxxxxx";
//	char arr2[] = "hello";
//
//	       //第一个参数arr1表示目标空间的数组名 数组名表示起始地址
//	       //第二个参数arr2表示源空间的数组名
//	//strcpy(arr1, arr2); //strcpy功能：把hello拷贝过去还会把\0拷贝过去
//
//	my_strcpy(arr1, arr2); //strcpy 有两个参数：1.目标空间的起始地址 2.源空间的起始地址
//	printf("%s\n", arr1); //打印字符串%s 只用给起始地址  作为字符串打印时，字符串结束标志是\0 printf也会停下来 不会再往后打印，即使arr1后面有x也不打印
//	return 0;
//}

int main()
{
	//改变num，把num的地址交给p，p作为指针变量接收num的地址时，对指针变量p进行解引用，就可以找到num，把num的值改成20
//	const 修饰变量，这个变量就被称为常变量，不能被修改，但本质上还是变量。       - 常变量不能被改变的量 具有常属性，又具有变量的属性
	                                                                             //常属性的意思是 它不能改，但是它本质上还是个变量
	const int num = 10; //本意加const 让num不能改
	//num = 20; //num不能被修改 表达式必须是可修改的左值 左值num - 指定为const对象

	//但把num的地址交给p
	//*p 指定为const对象 （*p就是p指向的内容）不能改

	//const 修饰指针变量时：  p    是指针变量本身
	//                        *p   是指针指向内容

	//const 放在*号左边作用，修饰的是*p         -  表示指针 指向的内容，不能通过指针来改变；但是指针变量本身是可以修改
	//const 放在*号右边作用，修饰的是指针变量p  -  表示指针变量不能被改变；                     但是指针指向的内容，可以被改变

    int const* p = &num; //取地址放到p里 p就是个整型指针
	//p如果是一个整型指针 放了num的地址 说明p指向了num
	*p = 20; //就把num的10改掉了  *p指针 指向的内容10，现在不能通过p来改变num *p = 20动作错误

	int n = 100;
	p = &n; //const int* p不能改变num，但是p可以指向其他变量 修改了p变量本身
	printf("%d\n", num);

	//int n = 100;
	//int* const p = &n;
	//*p = 20; //*p p指向的内容可以改变
	//p = &n; //但p变量本身不能改

	return 0;
}