#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//指针两层含义：
// 1.指针是地址
// 2.当地址或指针要存起来时，需要一个指针变量，指针变量是用来存放地址的
//   地址或指针存到变量里，变量被称为指针变量

//指针类型意义：
// 1.指针进行+-整数时，+1一步到底走多远 走一步到底多大距离。  整型指针+1 +4个字节；字符指针+1 +1个字节  类型所决定
// 2.指针解引用操作时，到底访问几个字节？   整型指针解引用访问4个字节；字符指针解引用只能访问1个字节    与类型有关

//野指针：指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
//造成野指针原因：

//1.指针未初始化
//int main()
//{
//	//指针变量未初始化，无法使用 p是野指针。没有向内存申请空间，无法访问
//	int* p; //局部变量指针未/不初始化，默认为随机值
//	   //p里面现在放的是一个随机的值，随机的值放到p里，p就以为随机的值是地址
//	*p = 20; //*p解引用操作 p里的数字当成地址 访问一块空间不属于当前程序  解引用20放进去 非法访问内存
//	return 0;
//}

//2.指针越界访问
//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i <= 10; i++)
//	{
//		//当指针指向范围超出 数组arr范围时，p是野指针
//		/**(p++) = i; */
//         *p = i; //解引用
//		 p++;
//
//	}
//	return 0;
//}

//3.指针指向的空间释放
//  动态内存开辟
//本来向内存申请了一块空间，但后来空间被释放掉了，p指针（记住的地址）也就是野指针了
//刚开始内存已分配空间，用完之后这块空间还给操作系统，但p变量里边还是记住了这块空间的起始地址，再通过p指针去访问这块空间，就是非法访问内存
//int *test()
//{
//	int a = 10; //进入test函数       进范围局部变量a创建
//	return &a; //返回a的地址假设0x0012ff40
//}//一旦返回去 a变量的生命周期就到了  出范围局部变量a销毁  4个字节内存就还给操作系统 被回收了
//int main()
//{
//	int* p = test(); //调用test函数
////拿int* p指针接收返回值  a的地址假设0x0012ff40放到p里边
//	*p = 20; //还想通过p里存的0x0012ff40这个地址 找到这块空间去访问把20放上，就是非法访问内存了  这个地址没意义 指向不确定 p是野指针
//	return 0;
//}

//避免野指针

////1.指针初始化
//int main()
//{
//	/*int a = 0;
//	printf("a = %d\n", a);*/
//
//	//当前 不知道指针变量p初始化 为 什么地址时,直接初始化为空指针NULL
//	int* p = NULL; //本质上NULL就是0  初始化为空指针 让系统不要随便乱用
//
//	//明确知道初始化的值
//	int a = 10;
//	int* prt = &a;
//
//	return 0;
//}

//2.小心指针越界 
//  C语言本身是不会检查数据的越界行为  
//  自己要保证数据不会越界

//3.指针指向空间释放及时置空NULL

//4.指针使用之前进行有效检查
//int main()
//{
//	int* p = NULL; //0地址 这块空间是没有分配给用户的 不能直接使用这块空间把值放进去
//	/**p = 10;*/ //F10调试 引发了未经处理的异常：写入访问权限冲突。p是空指针nullptr
//
//	if(p != NULL) //p等于空指针不用
//	*p = 10;  //p不等于空指针才用
//
//	//注意两点：
//	//1. 1）当一个指针变量不知道指向哪里，初始化为空指针；
//	//   2）当指向的空间不用时，再把指针指向空指针
//	//2.这样处理 指针要不然指向了一块有效空间（地址），要不然就是空指针
//	return 0;
//}

//指针运算
//1.指针+-整数     指针+-整数运算取决于指针类型 float型指针+1 +4个字节
//2.指针-指针
//3.指针的关系运算(比较大小)

//定义了一个符号
//#define N_VALUES 5
//int main()
//{
//    //数组随着下标的增长，地址由低到高变化
//	float values[N_VALUES]; //float定义了一个values数组 数组是5个元素
//	float* vp; //vp指针没有初始化
//
//	      //初始化部分      //判断部分           //调整部分可以省略不写。调整部分不执行，来打判断部分再判断
//	for (vp = &values[0]; vp < &values[N_VALUES];) //取出下标为5元素的地址
//		                  //指针的关系运算（指针比较了大小）
//	{//给vp赋了一个下标为0元素的地址
//		*vp++ = 0;
//		//指针+整数
//		//++是后置的  vp++表达式产生的结果是vp原来的值  解引用找到的是 vp当前指向的元素 把0放进去
//		//用完之后vp的后置++就会产生效果，vp++了就不在指向这个位置 而指向后面
//	}
//	return 0;
//}


#define N_VALUES 5

int main()
{
	float values[N_VALUES];
	float* vp;
	//for (vp = &values[0]; vp < &values[N_VALUES];)
	//{
	//	*vp++ = 0; //vp是后置++  vp++表达式的结果是vp原来的值 解引用找到的是 vp当前指向的元素  把0放进去
	//	           //使用完后vp的后置++就会产生效果  vp++了就不在指向这个位置  而指向了后面
	//}

	//指针-整数
	//for (vp = &values[N_VALUES]; vp > &values[0];)
	//{       //取出下标为5元素的地址
	//	*--vp=0;
	//}

	//避免这样写，因为标准并不保证它可行
	/*for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
	{
		*vp = 0;
	}*/
	//C语言标准规定：
	//允许指向数组元素的指针 与指向最后一个元素后面的那个内存位置的指针比较，
	//但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。
	return 0;
}

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	int* pend = arr + 9; //首元素地址+9跳过9个 指向10
//	while (p <= pend)
//	{
//		printf("%d\n", *p); //*p 把p指向的元素打印一下
//		p++; //p++ 让p往后走一步  p指向1  p指向2 ...... 以此类推
//	}
//
//	/*for (int i = 0; i < 10; i++)
//	{
//		printf("%d ", *p++);
//	}*/
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr; //拿一个指针变量 指向数组第一个元素
//	int* pend = arr + 9; //首元素地址+9 跳过9个 指向10  //拿一个指针变量 指向数组最后一个元素
//	while (p <= pend) // <=指向10的地址再进来  //拿指针关系运算  比较关系运算是不是到最后了
//	{
//		printf("%d\n", *p); //*p 把p指向的元素打印出来
//		p++; //p++ 让p指向下一元素  p++ 也运用了指针+整数
//	}
//	return 0;
//}

//指针和指针相减的前提是：两个指针指向同一块空间
//指针-指针 得到的是两个 指针之间的元素个数
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	//printf("%d\n", &arr[9] - &arr[0]); 
//	             //第10个元素的地址和第1个元素的地址中间有（1-9）9个元素
//	                //地址-地址
//	               // 指针-指针
//
//	char c[5];
//	printf("%d\n", &arr[9] - &c[0]); //从“char *”到“int *”的类型不兼容
//	             //arr[9]和c[0]类型不同，完全指向不同的空间，两个指针之间的元素个数 不知道怎么算 是char 字符的个数？ 还是int 整型的个数？
//	return 0;
//}

#include <string.h>
//1.求字符串长度――计数器方法
//int my_strlen(char* str) //用char* str 字符指针接收  str指向a
//{
//	//找\0之前出现了几个字符，那字符串的长度就是几
//	int count = 0;
//	//用while循环，因为找了很多次
//	while (*str != '\0')  //*str != '\0'说明找到了一个有效字符
//	{
//		count++; //只要*str != '\0' count++一下
//		str++;
//	}
//	return count;
//}

//2.求字符串长度――递归
//int my_strlen(char* str)
//{
//	if (*str != '\0') //说明字符串长度至少等于1
//	{
//		return 1+my_strlen(str+1); //递归不建议使用str++  ++str
//	}
//	else
//	{
//		return 0;
//	}
//
//}

//3.指针-指针
//int my_strlen(char* str)
//{
//	char* start = str;
//	while (*str != '\0')
//	{
//		str++;
//	}
//	return str - start;
//}

//int my_strlen(char* s)
//{
//	char* p = s;
//	while (*p != '\0')
//		p++;
//	return p - s;
//}
//
//int main()
//{
//	/*char arr[] = "abc";
//	int len = my_strlen(arr);*/
//	int len = my_strlen("abc"); //求字符串长度 求完后放到len里
//	                   //传参时 传过去的仅仅是首字符a的地址
//	printf("%d\n", len);
//	return 0;
//}